<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>PyConUA 2017</title>

		<meta name="description" content="Asyncio">
		<meta name="author" content="Nikolay Novik">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">
		<link rel="stylesheet" href="css/my.css">

		<!-- Code syntax highlighting -->
        <link class="codestyle" rel="stylesheet" href="css/tomorrow.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
<!-- ####################################################################  -->
               <section id="intro" class="aboutme">
                    <img src='images/ava5.png' style="background:none; border:none; box-shadow:none;">
                    <h1></h1>
                    <h1></h1>

					<h3>Key Concepts For Scalable Stateful Services</h3>
					<p> Nikolay Novik</p>
                    <p><a href="http://github.com/jettify">https://github.com/jettify</a></p>
					<p>PyConUA 2017</p>
			   </section>
<!-- ####################################################################  -->
				<section id="aobut_me">
                    <h3>I am ...</h3>
                    <ul>
                        <li><b>Software Engineer</b>: at DataRobot Ukraine</li>
                        <li><b>Github</b>: <a href="http://github.com/jettify">https://github.com/jettify</a></li>
                        <li><b>Twitter</b>: <a href="https://twitter.com/isinf">https://twitter.com/isinf</a></li>
                        <li><b>aio-libs</b>: <a href="https://github.com/aio-libs">https://github.com/aio-libs</a></li>
                        <li><b>My Projects</b>:
                            <ul>
                                <!-- TODO: add link to each project -->
                                <li><i>database clients</i>: <code>aiomysql, aioobc, aiogibson</code></li>
                                <li><i>web and etc</i>: <code>aiomonitor, aiohttp_debugtoolbar, aiobotocore,
                                    aiohttp_mako, aiohttp_admin, aiorwlock</code></li>
                            </ul>
                        </li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section id="poll"> <h5> Poll: Have you ever read dynamo paper?</h5>
                    <img src="images/dynamo_paper.png" height="400px">
                    <ol>
                        <li>I read this papers.</li>
                        <li>I heard about this paper and know key ideas.</li>
                        <li>I think distributed systems is kinda cool.</li>
                    </ol>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Agenda</h6>
                    <ol>
                        <font size="6">
                            <li>Motivation, why and when we might want to user stateful services.</li>
                            <li>Industry examples: Uber, Halo 4, DragonAge, HPC</li>
                            <li>Problem statement, required components</li>
                            <li>Overview of consitent hashing, gossip dissemination and swim failure detection</li>
                            <li>Possible improvements</li>
                        </font>
                    </ol>
				</section>
<!-- ####################################################################  -->
				<section>
                    <h6>Use Stateless<del> (Duck tape)</del>  When you can!</h6>
                    <img src="images/wd40.jpeg" height="400px">
                    <p> Stateless protocol is proven technique, use it when
                    your problem could be reduced to it! Stateless protocols
                    is new duck tape.</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Issues with Stateless services</h6>
                    <ul>
                        <li>Not all problems could be solved with stateless
                            approach, for example soft real time ones</li>
                        <li>Hard to be stateless, when state is huge and
                            pulling it form DB or serialization is very
                            expensive</li>
                        <li>We have all sorts of nasty problems when our
                            database should be sharded and database specifics
                            leaks into application</li>
                        <li>It’s wasteful to repeatedly pull resources into
                            load balanced services</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Stateless Service Example</h6>
                    <img src="images/stateless.svg" height="500px">
                    <p>Notice that user data fetched several times and cached
                    on multiple servers.</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Benefits of Stateful Services</h6>
                    <ul>
                        <li>Data locality, logic executed where data is stored
                            with fast access</li>
                        <li>"Stronger" consistency with sticky connections</li>
                        <li>Hight performance, no need to fetch state to the
                            load balanced node, data already is there</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Stateful Service Example</h6>
                    <img src="images/statefull.svg" height="500px">
                    <p>Avoided are extra trips to the database which reduces
                    latency. Even if the database is down the request can be
                    handled.</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Overview of frameworks for application clustering</h6>
                    <small>
                        <table>
                            <tr>
                                <th>Name</th>
                                <th>Language</th>
                                <th>Developer</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/uber/ringpop-node">RingPop</a></td>
                                <td>node.js</td>
                                <td>Uber</td>
                                <td>Used as services for matching user and driver with follow up location update</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/hashicorp/serf">Serf</a></td>
                                <td>golang</td>
                                <td>Hashicorp</td>
                                <td>Used in number applications for instance in HPC to manage computing resources</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/dotnet/orleans">Orleans</a></td>
                                <td>.NET</td>
                                <td>Microsoft</td>
                                <td>General purpose framework, used in Halo online game</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/orbit/orbit">Orbit/jGroups </a></td>
                                <td>Java</td>
                                <td>EA Games</td>
                                <td>Used in Bioware games, such as DragonAge game, not sure where thou. Inspired by Oreleans</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/basho/riak_core">riak_core</a></td>
                                <td>Erlang</td>
                                <td>Basho</td>
                                <td>Building block for Riak database and erlang distributed systems</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/akka/akka">Akka</a></td>
                                <td>Scala</td>
                                <td>Lightblend</td>
                                <td>General purpose distribute systems framework, often used as microservies platform</td>
                            </tr>
                            <tr>
                                <td>???</td>
                                <td>Python</td>
                                <td>???</td>
                                <td>???</td>
                            </tr>
                        </table>
                        </small>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Industry example: UBER</h6>
                    <img src='images/uber.png' height="450px">
                    <p>Driver sends volatile location information to dedicated server, updates replicated to neigbour
                    nodes. User with close location will be routed to same node as driver.</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Industry example: Halo 4</h6>
                    <img src='images/halo.png' height="550px">
                    <p>Orleans used as backbone for server part of Halo game,
                    including: presence, statistics, cheat detection, etc</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Industry example: HPC</h6>
                    <img src='images/San_Diego_Supercomputer_Center_East1.jpeg' height="450px">
                    <p>San Diego Supercomputer Center uses Serf to coordinate
                    compute resources in multiple locations, cluster size is about 2k nodes</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Real world problem for data scientists: Prediction service</h6>
                    <ul>
                        <p><i>We need scalable service, where user can upload models, and use them
                    in their APIs. For instance consider payment service, which
                    has models to detect fraud transaction or models that detects
                    strange user behaviour etc. User should only care about: </i></p>
                        <li>Deploy models to prediction servers</li>
                        <li>Hit models with API calls</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Problem definition</h6>
                        <div style="width: 100%;overflow:auto;">
                            <div style="float:left; width: 70%">
                    <img src='images/problem_definition.svg' height="400px">
                            </div>
                            <div style="float:right;width: 30%">
                                <font size="5">
                                    Requirements:
                                <ul>
                                    <li><b>Dynamic scaling</b>: servers could be added and removed on demand</li>
                                    <li><b>Fault tolerance</b>: cluster should be partially alive in case of network issues</li>
                                    <li><b>Exploit data locality</b>: model size is large, we need to avoid model reloading</li>
                                    <li><b>Flexible API</b>: user can connect to any node</li>
                                </ul>
                                </font>
                            </div>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Required components</h6>
                    <ol>
                        <li><i>Work distribution and routing</i> move job request to appropriate node</li>
                        <li><i>Cluster membership update</i> provide means to determine nodes participating in cluster in stable and cluster resizing conditions</li>
                        <li><i>Failure detector</i> periodically check nodes and remove unresponsive/dead ones</li>
                    </ol>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Routing. Naive solution with hard coded cluster nodes</h6>
                    <ul>
                        <li>Very easy to implement, viable solution when dynamic resizing is not required</li>
                        <li>Does not support dynamic scaling in or scaling out</li>
                        <li>Requires cluster restart for changing nodes configuration</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Routing. Consistent Hashing Solution</h6>
                    <img src="images/consitent_hashing.png" height="400px">
                    <p>Technique invented at MIT, grant supported by DARPA
                    and US Army. This simple algorithms made Akamai multi
                    billion worth company</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Consistent Hashing. Basic Idea</h6>
                    <img src="images/consistent-hashing_5.png" height="400px">
                    <p>Consistent hashing is a special kind of hashing such that
                    when a hash table is resized, only K/n keys
                    need to be remapped on average, where K is the number of
                    keys, and n is the number of slots</p>
                    <small><a href="http://blog.carlosgaldino.com/consistent-hashing.html">http://blog.carlosgaldino.com/consistent-hashing.html</a></small>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Consistent Hashing. Adding node</h6>
                    <img src="images/consistent-hashing_9.png" height="400px">
                    <p>In case of adding capacity, only fraction of
                    keys will be moved</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Consistent Hashing. Removing node</h6>
                    <img src="images/consistent-hashing_10.png" height="400px">
                    <p>In case of node failure next address will handle related keys</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Consistent Hashing. Virtual nodes</h6>
                    <img src="images/consistent-hashing_14.png" height="400px">
                    <p>While the expected load of each server is a 1/n fraction
                    of the objects, the realized load of each server will vary,
                    to fix this virtual nodes are used</p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Cluster Membership Problem</h6>
                    <img src="images/problem_1.svg" height="500px">
                    <p>
                    We have routing and job distribution, lets figure out how
                    to add and remove nodes.</p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Why not just use Zookeeper/Consul/Ectd (or in other words ZAB, Paxos, Raft)?</h6>
                    <img src="images/cap.svg" height="350px">
                    <font size="6">
                    <ul>
                        <li>CP systems emphasize consistency and same view on
                            data for each node. What is available to one can
                            be unavailable to other</li>
                        <li>Due to coordination overhead, approach is less
                            scalable, typically 10s of servers</li>
                        <li>Separate subsystem to support</li>
                    </ul>
                    </font>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Typical system with coordination</h6>
                    <img src='images/zookeeper.png' height="450px">
                    <font size="6">
                    <ul>
                        <li>Zookeeper forces own view of state of the system</li>
                        <li>Num number of possible commnunication links: $ \displaystyle edges = \frac{n (n -1) }{2} $ but for FD we use only $ n $ </li>
                        <li>Nodes availability decision best when it is local</li>
                    </ul>
                    </font>
				</section>
<!-- ####################################################################  -->

				<section>
					<h6>Cluster Membership Problem. Naive solution</h6>
                    <p> Each node should be able to broadcast states updates, and each
                    not faulty node should be able to receive this message.
                        </p>
                    <ul>
                        <li>Use network level technology to broadcast messages,
                            usually disabled on clouds</li>
                        <li>Send message one by one to each peer. Not efficient
                            and has reliability problems</li>
                    </ul>
				</section>
<!-- ####################################################################  -->

				<section>
					<h6>Gossip Overview</h6>
                    <p>
                    <img src="images/gossip2.svg" height="500px">
                    </p>
                    Basic gossip protocol: send message to k random peers,
                    peers retransmit message to next k random peers, in log(n)
                    steps, information will be disseminated.
				</section>
<!-- ####################################################################  -->

				<section>
					<h6>Gossip Dissemination Properties</h6>
                        <div style="width: 100%;overflow:auto;">
                            <div style="float:left; width: 70%">
                                \[ \frac{\text{d}x}{\text{d}t}=-\beta x y \]
                                with solution:
                                \[ y \approx (n + 1) - \frac{1}{n^{cb-2}} \]
                            </div>
                            <div style="float:right;width: 30%">
                                <font size="5">
                                    <ul>
                                        <li>$t = c\log(n)$</li>
                                        <li>$ \beta= \frac{b}{n}$</li>
                                        <li>$y$ number of infected node</li>
                                        <li>$n$ number of nodes</li>
                                        <li>$t$ time, $b$ number infected nodes per round</li>
                                    </ul>
                                </font>
                            </div>
                    <p>
                    <ul>
                        <li><i>Low latency</i> - data disseminated withing $c\log(n)$ rounds</li>
                        <li><i>Reliability/Fault tolerance</i> - after few rounds it is very hard to kill information spread</li>
                        <li><i>Lightweight</i> - only handful number of messages are transmitted $ cb\log(n)$</li>
                    </ul>
                    </p>
				</section>
<!-- ####################################################################  -->

				<section>
					<h6>Gossip Protocol and Packet loss</h6>
                    <img src="images/packet_loss.svg" height="500px">
                    <p>Heavy packet loss does not stop dissemination, it simply
                    will take a bit longer, 2 times for 50% loss.</p>

				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Failure detection protocol</h6>
                    <img src="images/problem_2.svg" height="500px">
                    <p>We can route jobs and communicate cluster update,
                    last component is failure detector.</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Failure detectors for asynchronous systems</h6>
                    <img src="images/fd.svg" height="300px">
                    <font size="6">
                    <ul>
                    <p>In asynchronous distributed systems, the detection of
                    <b>crash failures</b> is imperfect [2]. There will be <i>false positives</i>
                    and <i>false negatives</i>. 
                    </p>
                        <li><b>Completeness.</b> Every crashed process is eventually suspected</li>
                        <li><b>Accuracy.</b> No correct process is ever suspected</li>
                        <li><b>Speed.</b> How fast we can detect fault node</li>
                        <li><b>Network message load.</b> number of messages required during protocol period</li>
                    </ul>
                    </font>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Basic failure detector</h6>
                    <img src="images/hearbeet_fd.svg" height="400px">
                    <p>Each process periodically sends out an incremented
                    heartbeat counter to the outside world. Another
                    process is detected as failed when a heartbeat is not received
                    from it for some time</p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Basic failure detector. Properties</h6>
                    <ul>
                        <li><b>Completeness</b> each process eventually miss heartbeat</li>
                        <li><b>Speed</b> configurable, as little as protocol interval</li>
                        <li><b>Accuracy</b> high, depends on speed</li>
                        <li><b>Network message load.</b> $O(n^2)$ each node sends message to all other nodes</li>
                    </ul>
				</section>
<!-- ####################################################################  -->

				<section>
					<h6>SWIM failure detector</h6>
                    <img src="images/dynamo_paper.png" height="400px">
                    <p>SWIM: <b>S</b>calable <b>W</b>eakly-consistent <b>I</b>nfection-style
                    <b>P</b>rocess Group Membership. Protocol</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>SWIM Failure Detector</h6>
                    <img src="images/swim_fd2.svg" height="400px">
                    <font size="6">
                    <p>SWIM additional to ping/ack protocol adds indirect probing subgroup of
                    members to relay both pings and acks. The rationale for
                    using this approach, rather than sending k ping messages
                    directly to the peer, or relaying back acks in reply to ping-reqs
                    directly back to, is to avoid the effect of any congestion
                    on the network path between nodes.
                    </p></font>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>SWIM Failure Detector. Properties</h6>
                    <ul>
                        <li><b>Completeness</b> each process eventually will be pinged</li>
                        <li><b>Speed</b> configurable, 1 protocol interval</li>
                        <li><b>Accuracy</b> 99.9 % with delivery probability 0.95 and k=3 </li>
                        <li><b>Network message load.</b> $O(n)$ ($4k+2)n$)</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>SWIM Failure Detector. Accuracy improvement, suspicion subprotocol</h6>
                    <img src="images/swim_fsm.svg" height="300px">
                    <p>Provides a mechanism to reduce the rate of false
                    positives by “suspecting” a process before “declaring” it
                    as failed within the group.
                    </p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>SWIM Failure Detector packet order </h6>
                    <img src="images/message_order.svg" height="400px">
                    <p>Ordering between messages is important, but total
                    order is not required, only happens before/casual ordering.</p>
                    <ul>
                        <li>Logical timestamp for state updates</li>
                        <li>Peer specific and only incremented by peer </li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>SWIM Failure Detector Against Network Partitions</h6>
                    <img src="images/net_partition.svg" height="350px">
                    <p>Nodes in each subnet can talk to each as result
                    declares peers on other subnet as dead. How we can recover cluster after network heal?</p>
                    <ul>
                        <li>Do not purge nodes on dead</li>
                        <li>Periodically try to rejoin</li>
                    </ul>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Improvement: network coordinates</h6>
                    <img src="images/vivaldi.png" height="400px">
                    <p>Famous paper from MIT, describes synthetic network
                    coordinates, based on ping delays, used in Serf/Consul for
                    datacenter failover</p>
				</section>
<!-- ####################################################################  -->
				<section>
					<h6>Improvement: network coordinates visualisation</h6>
                    <img src="images/vivaldi.gif" height="400px">
                    <p>Notice coordinate drifting in space and stable distance between
                    clusters</p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Improvement: partial view for huge clusters</h6>
                    <img src="images/hyparview.png" height="400px">
                    <p>For huge clusters full membership is not scalable, paper proposes
                    partial membership protocol. Nodes maintain active view for
                    actively monitored nodes, and passive view for not monitored ones</p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Improvement: partial view incase of node failures</h6>
                    <img src="images/hyparview_plot.png" height="400px">
                    <p>Even for failure rates as high as 95%, HyParView still
                    manages to maintain a reliability value in the order of
                    deliveries to 90% of the active processes.
                    </p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Improvement: DHT for more balancing</h6>
                    <img src="images/orleans.png" height="400px">
                    <p>Orleans uses a one-hop distributed hash table
                    that maps GUIDs to their current activations’ locations
                    by way of partitioning the GUID hash space onto the cluster
                    nodes. Local caches are used to optimize away the network
                    round-trip in 90% of the cases </p>
				</section>

<!-- ####################################################################  -->
				<section>
					<h6>Stateful Services Challenges</h6>
                    <ul>
                        <li><b>Work distribution</b> - could be addressed by consistent hashing and DHT combination</li>
                        <li><b>Code deployment</b> - huge state is takes time to persist on disk and restore data, see how FB fixed this</li>
                        <li><b>Unbounded data structures</b> - back pressure should be implemented on day one</li>
                        <li><b>Memory management</b> - GC pauses may influence FD</li>
                        <li><b>Persistent strategies</b> - where and how persist state, DB, append log etc</li>
                    </ul>
				</section>

<!-- ####################################################################  -->
				<section>
					<h3>Read more papers!</h3>
				</section>
<!-- ####################################################################  -->
				<section>
					<h3>References</h3>
                    <font size="5">
                    <ol>
                        <li>Karger, David, et al. <i>"Consistent hashing and random trees: Distributed caching protocols for relieving hot spots on the World Wide Web."</i> Proceedings of the twenty-ninth annual ACM symposium on Theory of computing. ACM, 1997.</li>
                        <li>Chandra, Tushar Deepak, and Sam Toueg. <i>"Unreliable failure detectors for reliable distributed systems."</i> Journal of the ACM (JACM) 43.2 (1996): 225-267.</li>
                        <li>Das, Abhinandan, Indranil Gupta, and Ashish Motivala. <i>"Swim: Scalable weakly-consistent infection-style process group membership protocol."</i> Dependable Systems and Networks, 2002. DSN 2002. Proceedings. International Conference on. IEEE, 2002.</li>
                        <li>Dabek, Frank, et al. <i>"Vivaldi: A decentralized network coordinate system."</i> ACM SIGCOMM Computer Communication Review 34.4 (2004): 15-26.</li>
                        <li>Leitao, Joao, José Pereira, and Luis Rodrigues. <i>"HyParView: A membership protocol for reliable gossip-based broadcast."</i> Dependable Systems and Networks, 2007. DSN'07. 37th Annual IEEE/IFIP International Conference on. IEEE, 2007.</li>
                        <li>Stoica, Ion, et al. <i>"Chord: A scalable peer-to-peer lookup service for internet applications."</i> ACM SIGCOMM Computer Communication Review 31.4 (2001): 149-160.</li>
                        <li>Bailis, Peter, and Kyle Kingsbury. <i>"The network is reliable."</i> Queue 12.7 (2014): 20.</li>
                        <li>Lamport, Leslie. <i>"Time, clocks, and the ordering of events in a distributed system."</i> Communications of the ACM 21.7 (1978): 558-565.b</li>
                    </ol>
                    </font>
				</section>
<!-- ####################################################################  -->
				<section>
					<h2>Thank you!</h2>
                       and check out aio-libs!
					<p><a href="https://github.com/aio-libs">https://github.com/aio-libs</a></p>
                    <hr>
					<p>slides <a href="https://jettify.github.io/pyconua2017/">https://jettify.github.io/pyconua2017</a></p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom
                math: {
                        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
                        config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
                    },

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
